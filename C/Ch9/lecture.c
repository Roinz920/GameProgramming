#include "main.h"

/*
* 변수 : 변하는 수를 컴퓨터에 전달하기 위해 선언하는 것.
*
* 구분
* 지역(Local)
* 전역(Global)
*
* 0. 전역 변수가 더 큰 범위
* 1. 지역 변수가 전역 변수보다 우선적으로 사용 됨.
*/

/*
* 함수 내부에 선언된다 → 지역 변수
* 함수 외부에 선언된다 → 전역 변수
*
* 함수
* 반환값 이름(){}
  { } 내부에 변수가 선언되면 지역 변수 취급
  { } 외부에 변수가 선언되면 전역 변수 취급
*/

/*
* 변수의 이름이 같은에 왜 에러가 발생하지 않을까?
* = 컴퓨터가 변수의 이름이 같을 때에 구분할 수 있는 방법이 무엇일까?
* 선언된 변수가 저장되는 영역이 다르기 때문에 컴퓨터에서 구분이 가능함
*/

/*
* 영역이 나뉘는 이유?
*
* → 지역 변수의 특진
* (1) 함수의 내부에서 선언된다.
* (2) 함수가 종료되는 시점에서 변수가 소멸된다.
*
* → 전역 변수의 특진
* (1) 함수 외부에서 선언된다.
* (2) 프로그램이 종료되는 시점에 변수가 소멸된다.
*/

/*
* 변수 소멸 시점의 차이가 나는 이유는?
* 한정 된 메모리에서 효율적으로 사용하기 위함
* 사용된 공간을 지워서 다시 만듦.
*/

/*
* 전역 변수	|| main함수	|| LocalFunc 함수
   number	|| number	|| value\

   소멸 시점
   3		||	2		|| 1
*/
/*
- main 함수에서 num라는 지역 변수 선언과 동시에 10이라는 정수로 초기화
→ printf로 출력
→ LocalFunc() 함수를 찾아서 실행하되, ()에서 처음 발견되는 변수를 10이라는 정수로 초기화
→ LocalFuc(int a)를 발견 후, main 함수를 종료
→ 지역 변수로 초기화 된 number를 소멸

→ 전역 변수인 number가 재선언되고 1로 초기화 됨

→ LocalFunc에서 int a를 지역변수로 선언하고 1로 초기화
→ int value를 지역변수로 선언하고 5로 초기화
→ printf 출력 (결과값 : 15)
→ int value를 지역변수에 10이 추가되어 15로 초기화
→ LocalFunc 함수가 종료되며 지역함수 (int a, int value) 삭제 됨

→ main 함수로 돌아와서 int number를 지역함수로 다시 선언되며 10이 기록 됨
→ 다시 LocalFunc 함수를 발견하여 main 함수를 종료하고 LocalFunc 함수 실행
→ 동일한 지역함수 선언 (a, value)
→ value에 15가 기록되어있음...? (어?)
→ printf 로 출력 (
*/

void ShowExample()
{
	//printf("Ch9!\n");
	int number = 10; // 외부의 전역 변수의 이름을 함수 내부에서 선언. 그러나 error 없음
	printf("%d\n\n", number);

	LocalFunc(10);
	LocalFunc(15);

}

void LocalFunc(int a)
{
	int value = 5;
	printf("a에 %d를 더한 값 : %d\n", value, (a + value));
	value += 10;
}
